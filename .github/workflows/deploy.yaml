name: Spring Boot CI/CD to AWS EC2

on:
  push:
    branches:
      - dev # 'dev' 브랜치에 푸시될 때 워크플로우 실행

env:
  # Docker Hub 레포지토리 정보 (본인의 Docker Hub 사용자 이름과 프로젝트 이름으로 변경)
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  DOCKER_IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/siruchat-app # 예: mydockerhubid/siruchat-app

  # EC2 접속 정보 (GitHub Secrets에서 가져옴)
  EC2_HOST: ${{ secrets.EC2_HOST }} # EC2 퍼블릭 DNS 또는 IP
  EC2_USER: ec2-user # AWS Linux/UNIX 기본 사용자 (실제 EC2 사용자명으로 변경: 예: 'ubuntu' 또는 'admin')
  EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }} # EC2 개인 키 내용

  # EC2에서 docker-compose.yaml과 프로젝트 파일들이 위치할 최종 디렉토리
  # 이 디렉토리는 EC2 사용자 홈 디렉토리 내에 존재해야 하며,
  # docker-compose.yaml 파일이 이미 여기에 있다고 가정합니다.
  # 여기서는 EC2_USER 값을 직접 사용합니다 (예: ec2-user)
  PROJECT_DIR_ON_EC2: /home/ec2-user/siruchat-project # <-- 이 부분을 이렇게 변경

jobs:
  # 1. Spring Boot 애플리케이션 빌드 및 Docker Hub에 이미지 푸시
  build-and-push:
    runs-on: ubuntu-latest # GitHub Actions 러너 환경
    steps:
      - name: Checkout code # GitHub 저장소에서 코드 체크아웃
        uses: actions/checkout@v4

      - name: Set up JDK 17 # Java 17 환경 설정
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'gradle' # Gradle 캐시 활성화

      - name: Grant execute permission for gradlew # gradlew 실행 권한 부여
        run: chmod +x gradlew

      - name: Build Spring Boot application with Gradle # Gradle로 Spring Boot 애플리케이션 빌드
        run: ./gradlew bootJar

      - name: Log in to Docker Hub # Docker Hub 로그인
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }} # Docker Hub 비밀번호 (GitHub Secrets)

      - name: Build and push Docker image # Docker 이미지 빌드 및 Docker Hub에 푸시
        uses: docker/build-push-action@v5
        with:
          context: . # 현재 디렉토리를 빌드 컨텍스트로 사용
          push: true # 이미지 푸시
          tags: ${{ env.DOCKER_IMAGE_NAME }}:${{ github.sha }} # 커밋 SHA를 태그로 사용 (고유한 버전 식별)


  # 2. EC2에 배포 (docker-compose 사용)
  deploy:
    runs-on: ubuntu-latest # GitHub Actions 러너 환경
    needs: build-and-push # 'build-and-push' 작업이 성공적으로 완료된 후 실행
    steps:
      - name: Checkout code (to access Dockerfile for build context on EC2)
        uses: actions/checkout@v4 # Dockerfile과 빌드 아티팩트를 EC2에 복사하기 위함

      - name: Deploy with Docker Compose on EC2 # EC2에 SSH 접속 및 배포 스크립트 실행
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.EC2_HOST }} # EC2 호스트 주소
          username: ${{ env.EC2_USER }} # EC2 사용자명
          key: ${{ env.EC2_SSH_KEY }} # EC2 SSH 개인 키
          script: |
            echo "Moving to project directory on EC2 where compose.yaml exists..."
            # 대상 디렉토리가 없다면 생성하고, 해당 디렉토리로 이동
            mkdir -p ${{ env.PROJECT_DIR_ON_EC2 }}
            cd ${{ env.PROJECT_DIR_ON_EC2 }}

            echo "Log in to Docker Hub..."
            docker login -u ${{ env.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}

            echo "Copying application source/build context to EC2..."
            # GitHub Actions 러너의 현재 작업 공간($GITHUB_WORKSPACE) 내용을 EC2의 지정된 프로젝트 디렉토리로 동기화
            # --exclude 옵션을 사용하여 Git 관련 파일, Node.js 모듈, Gradle 캐시 등 불필요한 파일 제외
            # 이 단계를 통해 docker-compose.yaml에서 참조하는 Dockerfile과 빌드된 JAR 파일을 EC2에서 찾을 수 있습니다.
            rsync -avz --exclude '.git' --exclude 'node_modules' --exclude '.gradle' "$GITHUB_WORKSPACE/" "${{ env.PROJECT_DIR_ON_EC2 }}/"

            echo "Stopping existing containers defined in compose.yaml..."
            # compose.yaml에 정의된 모든 컨테이너를 안전하게 중지하고 삭제합니다.
            # '|| true'는 컨테이너가 실행 중이지 않아도 스크립트가 실패하지 않도록 합니다.
            docker-compose -f compose.yaml down || true

            echo "Starting containers with Docker Compose..."
            # docker-compose.yaml에 필요한 환경 변수들을 전달하여 서비스들을 시작합니다.
            # 이 변수들은 compose.yaml 내의 ${VAR_NAME} 플레이스홀더에 바인딩됩니다.
            # Docker Compose는 이 환경 변수들을 읽어 각 서비스 컨테이너에 주입합니다.
            DOCKER_USERNAME=${{ env.DOCKER_USERNAME }} \
            DOCKER_IMAGE_NAME=${{ env.DOCKER_IMAGE_NAME }} \
            MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }} \
            MYSQL_USERNAME=${{ secrets.MYSQL_USER }} \
            MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }} \
            MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }} \
            RABBITMQ_USERNAME=${{ secrets.RABBITMQ_USERNAME }} \
            RABBITMQ_PASSWORD=${{ secrets.RABBITMQ_PASSWORD }} \
            REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }} \
            MONGO_USERNAME=${{ secrets.MONGO_USERNAME }} \
            MONGO_PASSWORD=${{ secrets.MONGO_PASSWORD }} \
            MONGO_DB=${{ secrets.MONGO_DB }} \
            JWT_SECRET=${{ secrets.JWT_SECRET }} \
            docker-compose -f compose.yaml up -d --build siruchat # 'siruchat' 서비스만 재빌드하여 최신 앱 이미지 반영
            echo "Deployment complete."